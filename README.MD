# VG BrainSystem Link
## Описание
Это библиотека, реализующая интерфейс связи между брейн-системами и между системами и внешними дисплеями
## Интерфейс
Основной интерфейс библиотеки - `vgs::link::Link`. Он реализует двухстороннюю связь типа "точка-точка". Поддержание нескольких соединений не предусмотрено. Для этих целей можно создавать несколько объектов интерфейса.

Интерфейс является абстрактным, то есть его методы не реализованы. В библиотеке есть готовые реализации интерфейса, также можно создать свою.

 ### Методы:
 - `void tick()`- вызывается в цикле (loop у Arduino). Реализация должна при вызове этого метода получить новые сообщения и обновить свое состояние
 - `vgs::link::Command getCommand()`- получить последнюю команду
 - `unsigned int getData()`- получить данные из последней команды
 - `void send(vgs::link::Command command, unsigned int data = 0)`- отправить команду и (опционально) данные

### Команды:

 - `Command::None`- пустая команда. Фактически ничего не отправляется. Возвращается в `getCommand()`, если за `tick()` новые данные получены не были
 - `Command::PlayerButton` - событие нажатия на кнопку (именно факта нажатия, а не результата). Передается исключительно от подчиненных систем главной. В данных номер кнопки (в нумерации подчиненной системы)
 - `Command::PlayerLedOn`- включить лампочку игрока. Означает, что игрок нажал кнопку верно (без фальстарта). Передается от главной системы к подчиненным. Игнорируется дисплеями. В данных номер кнопки (в нумерации подчиненной системы, совпадает с номером при событии нажатия)
 - `Command::DisplayPlayerLedOn`- означает, что игрок нажал кнопку верно (без фальстарта). Передается от системы к дисплею. Игнорируется другими системами. В данных номер кнопки (в нумерации системы)
 - `Command::PlayerLedBlink`- включить лампочку игрока в мигающий режим. Означает, что игрок нажал фальстарт. Передается от главной системы к подчиненным. Игнорируется дисплеями. В данных номер кнопки (в нумерации подчиненной системы, совпадает с номером при событии нажатия)
 -  `Command::DisplayPlayerLedBlink`- означает, что игрок нажал фальстарт. Передается от системы к дисплею. Игнорируется другими системами. В данных номер кнопки (в нумерации системы)
 -  `Command::SignalLedOn`- означает, что система запущена. Обычно используется для включения сигнала старта. Передается от системы к дисплею и от главной системы к подчиненным. Данных нет (игнорируются)
 -  `Command::LedsOff`- погасить все лампочки. Используется при сбросе и перед сигнализацией нажатия. Передается от системы к дисплею и от главной системы к подчиненным. Данных нет (игнорируются)
 -  `Command::UpdateTime`- обновить время. Используется для показа оставшихся секунд при отсчете. Передается от системы к дисплею и от главной системы к подчиненным. В данных - оставшееся время в секундах
 
 
## Поддерживаемы протоколы
В настоящий момент поддерживаются следующие протоколы

 - UART

### UART
Интерфейс базируется на стандартной реализации TTL UART (Serial в среде Arduino). 
#### Версии:

 - V1
 - V2

#### Параметры:

 - Напряжение: TTL (3.3/5В)
 - Скорость: 9600 бод
 - Формат пакета: 8-N-1

#### Команды 
Все команды передаются в виде одного байта. Для всех команд старшие 4 бита несут информацию о самой команде, младшие 4 бита содержат данные (или игнорируются). Для команды UpdateTime старший бит равен 1, остальные содержат данные.

##### V1
Версия является устаревшей. Используется только для обратной совместимости с уже выпущенными системами. Содержит несоответствие между номерами игроков для команд PlayerButton и PlayerLedOn/Blink. Соотношение между номерами: pl = pb + 4
|     Название    | Команда |  Формат  |             Данные            | 
|        --       |    --   |    --    |               --              |
| PlayerButton    |   0x00  | 0000xxxx |    номер игрока, от 0 до 3    |
| LedsOff         |   0x10  | 0001xxxx |                -              |
| PlayerLedOn     |   0x20  | 0010xxxx |    номер игрока, от 4 до 7    |
| PlayerLedBlink  |   0x30  | 0011xxxx |    номер игрока, от 4 до 7    |
| SignalLedOn     |   0x40  | 0100xxxx |                -              |
| UpdateTime      |   0x80  | 1xxxxxxx | время в секундах, от 0 до 127 |

##### V2
На текущий момент актуальная версия
|       Название        | Команда |  Формат  |             Данные            | 
|          --           |    --   |    --    |               --              |
| PlayerButton          |   0x00  | 0000xxxx |    номер игрока, от 0 до 7    |
| LedsOff               |   0x10  | 0001xxxx |                -              |
| PlayerLedOn           |   0x20  | 0010xxxx |    номер игрока, от 0 до 7    |
| PlayerLedBlink        |   0x30  | 0011xxxx |    номер игрока, от 0 до 7    |
| SignalLedOn           |   0x40  | 0100xxxx |                -              |
| DisplayPlayerLedOn    |   0x50  | 0101xxxx |    номер игрока, от 0 до 7    |
| DisplayPlayerLedBlink |   0x60  | 0110xxxx |    номер игрока, от 0 до 7    |
| UpdateTime            |   0x80  | 1xxxxxxx | время в секундах, от 0 до 127 |

#### API
Логика работы находится в классе `vgs::link::UartLink`. Класс реализует интерфейс `vgs::link::Link` и все его абстрактные методы.
Класс имеет два своих абстрактных protected метода, которые нужно переопределить в реализации:

 - `void writeUartData(char data)` - отправить 1 байт по UART
 - `bool readUartData(char& data)` - если доступны байты для чтения, прочитать один и вернуть `true`. Иначе вернуть `false`

Логика класса зависит от версии протокола, указанной при создании объекта:

 - `UartLinkVersion::V1`
 - `UartLinkVersion::V2`

Версия может быть получена из объекта класса методом `getVersion()`.

#### ArduinoUartLink
Класс `vgs::link::ArduinoUartLink` является реализацией `UartLink` для Arduino-совместимых контроллеров.

Конструктор: `ArduinoUartLink(HardwareSerial* serial, UartLinkVersion version = UartLinkVersion::V2)`

Реализованы все методы

Пример использования: 

    vgs::link::UartLink* link;
    
    void  setup()
	{
		Serial.begin(9600, SERIAL_8N1);
		link = new ArduinoUartLink(&Serial);
	}
	
	void loop()
	{
		link->tick();
		vgs::link::Command command = link->getCommand();
		switch (command)
		{
			// логика в зависимости от команды
			// если нужно ответить, link->send(...)
		}
	}